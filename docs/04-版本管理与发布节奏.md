# 技术文档（四）：版本管理与发布节奏（语义化版本、Changelog、Release Note）

`unifiles` 已完成 MVP 并具备 CI / 自动发布能力，接下来要做的是：**把「版本号」「改动记录」和「发布时间点」管理好**，让用户和未来的你都能看懂每一次发布的意义。

本文重点讲三件事：

- 版本号如何设计：**语义化版本（SemVer）**
- 每次改动如何记录：**Changelog / HISTORY**
- 每次发布如何对外说明：**Release Note（通常在 GitHub Releases 上）**

---

## 1. 语义化版本（Semantic Versioning）

### 1.1 基本规则

采用经典的语义化版本规范：`MAJOR.MINOR.PATCH`，例如：`1.2.3`。

- **MAJOR（大版本）**：有不兼容改动（Breaking Changes）
  - 改了函数签名、删了 API、行为有本质差异，老用户升级后代码可能直接挂掉。
- **MINOR（小版本）**：向后兼容的新功能
  - 新增函数、新增参数（有默认值）、性能优化、新模块等，不破坏现有用法。
- **PATCH（补丁版本）**：向后兼容的 Bug 修复 / 小改进
  - 修 Bug、修文档小错误、内部实现优化但不改变行为。

> 简化记忆：  
> - 破坏兼容 = **+1 MAJOR，MINOR/PATCH 清零**  
> - 新功能、兼容老用户 = **+1 MINOR，PATCH 清零**  
> - 修 Bug / 小优化 = **+1 PATCH**

### 1.2 在 unifiles 中的约定

当前版本是：

- `pyproject.toml`：`version = "0.1.0"`
- `src/unifiles/__init__.py`：`__version__ = "0.1.0"`

结合项目现状，推荐约定：

- `0.x.y` 阶段：整体仍处于「快速迭代 / API 尚不完全稳定」阶段。
  - 可以存在一定程度的破坏性改动，但要在 Changelog / Release Note 中 **明确标注**。
- 从 `1.0.0` 开始：
  - 将视为「稳定 API」，**对外公开的函数签名尽量不再做破坏性变更**。

建议的版本演进示例：

- `0.1.0`：MVP（Excel / PDF / Word / SQLite）+ 基本测试 + 手动发布流程
- `0.2.0`：新增 CSV / JSON 支持（兼容加法）
- `0.2.1`：修复某个 PDF 表格提取 Bug
- `0.3.0`：新增一组批量处理接口（兼容）
- `1.0.0`：API 较稳定、文档完整、常见 Bug 已修，宣布「正式版」

---

## 2. 版本号修改流程（项目内一致性）

为了避免「版本号不同步」，每次发布前建议严格执行：

1. 修改 `pyproject.toml`：
   ```toml
   [project]
   name = "unifiles"
   version = "0.2.0"  # 例如从 0.1.0 升级到 0.2.0
   ```
2. 修改 `src/unifiles/__init__.py`：
   ```python
   __version__ = "0.2.0"
   ```
3. 更新 Changelog（见下文）。
4. 提交代码并 push。
5. 创建 Tag（例如 `v0.2.0`），触发 GitHub Actions 自动发布。

> 提示：未来可以考虑写一个小工具（Python 脚本 / pre-commit hook），自动同步修改这两个位置，减少手工出错概率。

---

## 3. Changelog（变更记录）的设计与维护

### 3.1 为什么要有 Changelog

- 给 **使用者**：一眼看到每个版本做了什么改动、是否安全升级。
- 给 **维护者**：回顾历史决策、追踪 Bug 引入时间、辅助回滚。

相比一堆散乱的 commit，**按版本整理的 Changelog** 可读性更高。

### 3.2 文件选择与位置

你已经有：

- `HISTORY.md`：记录「用户指令历史」

建议再增加一个更面向用户 / 版本的：

- `CHANGELOG.md`（或在 `HISTORY.md` 中增加“版本记录”部分，但建议独立文件更清晰）

项目结构示意：

```text
unifiles/
├── CHANGELOG.md        # 面向用户的版本变更记录
├── HISTORY.md          # 你与助手的指令历史（内部用）
├── docs/
│   ├── 01-发布Python包到PyPI.md
│   ├── 02-使用GitHub-Actions搭建CI流水线.md
│   └── 03-用GitHub-Actions自动发布到PyPI.md
└── ...
```

### 3.3 推荐格式（类似 “Keep a Changelog”）

一个简单、清晰的格式示例：

```markdown
# Changelog

所有显著变更都会记录在此文档中。

## [Unreleased]

- （这里先写下次版本准备做的改动，发布时再移动到具体版本）

## [0.1.0] - 2026-01-28

### Added
- Excel 模块：`read_excel` / `write_excel` / `get_sheet_names`
- PDF 模块：`extract_text` / `extract_tables`
- Word 模块：`read_docx` / `write_docx`
- SQLite 模块：`query` / `get_schema` / `get_tables`
- 基本单元测试与性能测试
- 发布到 PyPI 的文档与脚本
```

常用小节：

- `### Added`：新增功能
- `### Changed`：行为变更（注意是否兼容）
- `### Fixed`：修复
- `### Removed`：移除
- `### Deprecated`：标记为将废弃

### 3.4 更新节奏

- 每次准备发新版本：
  - 在 `[Unreleased]` 小节中先记录改动（写在开发过程中）。
  - 发布前，将 `[Unreleased]` 中的内容移动到新版本小节（如 `[0.2.0] - 2026-02-10`），再清空 `[Unreleased]`。

---

## 4. Release Note（发布说明）

Changelog 偏向 **“对比版本之间”** 的技术列表，而 Release Note 更像是 **“新闻稿 / 公告”**，通常放在：

- GitHub Releases 页面
- 企业内部文档 / 群公告

### 4.1 在 GitHub Releases 中书写

推荐流程：

1. 代码已在 main 上，版本号和 Changelog 更新完毕。
2. 打 Tag（如 `v0.2.0`），触发 GitHub Actions 发布流程。
3. 在 GitHub 仓库的 **Releases** 页面：
   - 新建 Release，选择 `v0.2.0` Tag。
   - Release Title：`v0.2.0 - 新增 CSV/JSON 支持`（简洁说明亮点）。
   - Release body：可以直接复制 `CHANGELOG.md` 对应版本的小节，并适当润色。

Release Note 结构建议：

```markdown
## 亮点
- 新增 CSV / JSON 文件支持
- PDF 表格抽取性能优化

## 详细改动

### Added
- `read_csv` / `write_csv`
- `read_json` / `write_json`

### Fixed
- 修复了 PDF 某些页无法抽取文本的问题
```

### 4.2 与自动发布流程的结合

在第三篇文档的自动发布工作流中：

- 打 Tag → CI → 发布到 TestPyPI / PyPI
- 你可以选择：
  - 手动在 GitHub Releases 中创建 Release 并撰写 Release Note。
  - 或将来接入自动生成 Changelog / Release Note 的工具（如基于 commit message 的脚本），但这可以后续再做。

---

## 5. 发布节奏建议（unifiles 项目）

结合你现在的项目规模和目标，推荐一个 **轻量但有节奏感** 的发布策略：

- **补丁版本（PATCH）**：
  - 频率：**随时**，有 Bug 就修，有小优化就发。
  - 要求：Changelog 写清楚，CI 通过即可。
- **小版本（MINOR）**：
  - 频率：视功能积累情况，**1–2 个月一次** 即可。
  - 要求：
    - 至少有一两项对用户有感知的新功能。
    - 文档（README / docs/）同步更新使用示例。
    - 写一份稍微完整一点的 Release Note。
- **大版本（MAJOR）**：
  - 在你认定 API 稳定、使用者较多时再考虑 `1.0.0`。
  - 之后有 Breaking Change 时才 bump MAJOR。

小贴士：

- 尽量避免长时间憋着不发：**小步快跑更利于用户和维护者**。
- 每次发版前，用本地 `publish_pypi.bat` 或 TestPyPI 流水线先跑一遍，确认流程健康。

---

## 6. 总结

- **语义化版本**：`MAJOR.MINOR.PATCH`，用来表达「破坏性 / 新功能 / 修 Bug」的区别。
- **Changelog**：为每个版本记录「做了什么、对谁有影响」，建议使用 `CHANGELOG.md` 独立维护。
- **Release Note**：面向用户的发布说明，可以基于 Changelog 精简/润色，放在 GitHub Releases 上。
- **发布流程**：本地脚本 + CI + 自动发布，使整个版本生命周期「有节奏」「可追溯」「可复现」。

后续如果你愿意，我们可以直接在项目里创建一个 `CHANGELOG.md` 初稿，并约定从下一个版本开始严格按照本文流程走一遍。 
